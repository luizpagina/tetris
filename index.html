<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Tetris Luisa & Catharina - Mobile</title>
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
* {
    box-sizing: border-box;
    font-family: Arial, Helvetica, sans-serif;
}

body {
    margin: 0;
    background-color: #000;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;

    /* Foto de fundo */
    background-image: url("background.png");
    background-repeat: no-repeat;
    background-position: center top;
    background-size: contain;
}

#title {
    margin-top: 6px;
    text-align: center;
    font-size: 14px;
    line-height: 1.4;
    text-shadow: 0 0 4px #000;
}

#title strong {
    font-size: 16px;
}

#game-container {
    margin-top: 10px;
    padding: 10px;
    background: rgba(0,0,0,0.35);  /* mais transparente pra foto aparecer */
    border-radius: 16px;
    display: flex;
    gap: 10px;
}

/* em telas bem estreitas, empilha */
@media (max-width: 420px) {
    #game-container {
        flex-direction: column;
        align-items: center;
    }
}

#canvas {
    border-radius: 10px;
    background: rgba(0,0,0,0.45);
}

#sidebar {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 13px;
}

#score-box {
    margin-top: 4px;
    padding: 4px 6px;
    background: rgba(0,0,0,0.4);
    border-radius: 8px;
}

#next-box {
    margin-top: 8px;
    padding: 6px;
    background: rgba(0,0,0,0.5);
    border-radius: 10px;
    border: 1px solid #fff;
    text-align: center;
}

#next-box div {
    margin-bottom: 4px;
    font-size: 13px;
}

#next-canvas {
    background: #111;
    border-radius: 6px;
}

#tips {
    margin-top: 8px;
    font-size: 12px;
    text-align: center;
    max-width: 140px;
    line-height: 1.3;
    opacity: 0.9;
}
</style>
</head>
<body>

<div id="title">
    <strong>Tetris da Luisa & Catharina</strong><br>
    Criado por: Luiz Carlos ¬∑ Toque para girar ¬∑ Arraste para mover/baixar
</div>

<div id="game-container">
    <canvas id="canvas" width="240" height="480"></canvas>

    <div id="sidebar">
        <div id="score-box">
            Score: <span id="score">0</span><br>
            Linhas: <span id="lines">0</span>
        </div>

        <div id="next-box">
            <div>Pr√≥xima pe√ßa:</div>
            <canvas id="next-canvas" width="80" height="80"></canvas>
        </div>

        <div id="tips">
            ‚òùÔ∏è Toque r√°pido gira a pe√ßa<br>
            üëâ Arraste para os lados<br>
            üëá Arraste para baixo acelera
        </div>
    </div>
</div>

<script>
// ===========================
// √ÅUDIO (musica.mp3 na mesma pasta)
// ===========================
let bgm = new Audio("musica.mp3");
bgm.loop = true;
let musicStarted = false;

function startMusic() {
    if (!musicStarted) {
        musicStarted = true;
        bgm.play().catch(() => {
            musicStarted = false; // tenta de novo no pr√≥ximo toque
        });
    }
}

// ===========================
// CONFIGURA√á√ÉO DO TETRIS
// ===========================
const W = 10;   // largura em blocos
const H = 20;   // altura em blocos
const S = 24;   // tamanho do bloco (px)

const canvas = document.getElementById("canvas");
const ctx    = canvas.getContext("2d");

canvas.width  = W * S;
canvas.height = H * S;

const nextCanvas = document.getElementById("next-canvas");
const nextCtx    = nextCanvas.getContext("2d");

const scoreEl = document.getElementById("score");
const linesEl = document.getElementById("lines");

let field = new Array(W * H).fill(0);
let tetromino = [];

// Pe√ßas 4x4
tetromino[0] = "..X."+
               "..X."+
               "..X."+
               "..X."; // I

tetromino[1] = "..X."+
               ".XX."+
               ".X.." +
               "...."; // S

tetromino[2] = ".X.." +
               ".XX."+
               "..X."+
               "...."; // Z

tetromino[3] = ".XX."+
               ".XX."+
               "...."+
               "...."; // O

tetromino[4] = "..X."+
               ".XX."+
               "..X."+
               "...."; // T

tetromino[5] = "...X"+
               ".XXX"+
               "...."+
               "...."; // L

tetromino[6] = "X..." +
               "XXX."+
               "...."+
               "...."; // J

const colors = [
    "#000000",
    "#00BFFF",
    "#2ECC71",
    "#FFB347",
    "#F7DC6F",
    "#AF7AC5",
    "#E74C3C",
    "#FF69B4"
];

let currentPiece = 0;
let currentRotation = 0;
let currentX = 3;
let currentY = 0;
let nextPiece = 0;

let score = 0;
let lines = 0;
let fallInterval = 800;   // mais lento para crian√ßa
let fallTimer = 0;
let lastTime = 0;
let gameOver = false;

// "Ox√™e!"
let oxeTimer = 0;
const OXE_DURATION = 800;

// controle de toque
let touchStartX = 0;
let touchStartY = 0;
let touchStartTime = 0;

// controle pra n√£o girar muito r√°pido
let lastRotateTime = 0;
const ROTATE_COOLDOWN = 220; // ms

// ==================== Fun√ß√µes base ====================
function rotate(px, py, r) {
    switch (r % 4) {
        case 0: return py * 4 + px;
        case 1: return 12 + py - (px * 4);
        case 2: return 15 - (py * 4) - px;
        case 3: return 3 - py + (px * 4);
    }
    return 0;
}

function doesPieceFit(t, r, posX, posY) {
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, r);
            if (tetromino[t][pi] === "X") {
                const fx = posX + px;
                const fy = posY + py;
                if (fx < 0 || fx >= W || fy < 0 || fy >= H) return false;
                if (field[fy * W + fx] !== 0) return false;
            }
        }
    }
    return true;
}

function newGame() {
    field.fill(0);
    score = 0;
    lines = 0;
    fallInterval = 800;
    fallTimer = 0;
    oxeTimer = 0;
    gameOver = false;

    currentPiece = Math.floor(Math.random() * 7);
    nextPiece    = Math.floor(Math.random() * 7);
    currentRotation = 0;
    currentX = 3;
    currentY = 0;

    scoreEl.textContent = score;
    linesEl.textContent = lines;
}

// trava pe√ßa, verifica linhas, gera nova
function lockPiece() {
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, currentRotation);
            if (tetromino[currentPiece][pi] === "X") {
                const fx = currentX + px;
                const fy = currentY + py;
                if (fx >= 0 && fx < W && fy >= 0 && fy < H) {
                    field[fy * W + fx] = currentPiece + 1;
                }
            }
        }
    }

    let cleared = 0;
    for (let y = 0; y < H; y++) {
        let full = true;
        for (let x = 0; x < W; x++) {
            if (field[y * W + x] === 0) { full = false; break; }
        }
        if (full) {
            cleared++;
            for (let yy = y; yy > 0; yy--) {
                for (let x = 0; x < W; x++) {
                    field[yy * W + x] = field[(yy - 1) * W + x];
                }
            }
            for (let x = 0; x < W; x++) field[x] = 0;
        }
    }

    if (cleared > 0) {
        lines += cleared;
        if (cleared === 1) score += 100;
        else if (cleared === 2) score += 300;
        else if (cleared === 3) score += 500;
        else score += 800;

        scoreEl.textContent = score;
        linesEl.textContent = lines;

        oxeTimer = OXE_DURATION;
        if (fallInterval > 200) fallInterval -= 20;
    }

    currentPiece = nextPiece;
    nextPiece    = Math.floor(Math.random() * 7);
    currentRotation = 0;
    currentX = 3;
    currentY = 0;

    if (!doesPieceFit(currentPiece, currentRotation, currentX, currentY))
        gameOver = true;
}

// desenha pr√≥xima pe√ßa
function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    nextCtx.fillStyle = "#111";
    nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

    const cell = 16;
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, 0);
            if (tetromino[nextPiece][pi] === "X") {
                nextCtx.fillStyle = colors[(nextPiece + 1) % colors.length];
                nextCtx.fillRect(px * cell + 8, py * cell + 8, cell - 2, cell - 2);
            }
        }
    }
}

// desenho geral
function draw(dt) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // grade
    ctx.strokeStyle = "rgba(230,230,230,0.25)";
    ctx.lineWidth = 1;
    for (let x = 0; x <= W; x++) {
        ctx.beginPath();
        ctx.moveTo(x * S, 0);
        ctx.lineTo(x * S, H * S);
        ctx.stroke();
    }
    for (let y = 0; y <= H; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * S);
        ctx.lineTo(W * S, y * S);
        ctx.stroke();
    }

    // blocos travados
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const v = field[y * W + x];
            if (v > 0) {
                ctx.fillStyle = colors[v % colors.length];
                ctx.fillRect(x * S + 1, y * S + 1, S - 2, S - 2);
            }
        }
    }

    // pe√ßa atual
    if (!gameOver) {
        for (let px = 0; px < 4; px++) {
            for (let py = 0; py < 4; py++) {
                const pi = rotate(px, py, currentRotation);
                if (tetromino[currentPiece][pi] === "X") {
                    const gx = currentX + px;
                    const gy = currentY + py;
                    if (gx >= 0 && gx < W && gy >= 0 && gy < H) {
                        ctx.fillStyle = colors[(currentPiece + 1) % colors.length];
                        ctx.fillRect(gx * S + 1, gy * S + 1, S - 2, S - 2);
                    }
                }
            }
        }
    }

    // Ox√™e!
    if (oxeTimer > 0) {
        oxeTimer -= dt;
        ctx.font = "26px Arial";
        ctx.fillStyle = "yellow";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Ox√™e!", canvas.width / 2, canvas.height / 2);
    }

    // Game over
    if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.fillRect(20, canvas.height / 2 - 40, canvas.width - 40, 80);
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "20px Arial";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 6);
        ctx.font = "14px Arial";
        ctx.fillText("Toque para jogar de novo", canvas.width / 2, canvas.height / 2 + 18);
    }

    drawNextPiece();
}

// loop principal
function loop(timestamp) {
    const dt = lastTime ? (timestamp - lastTime) : 0;
    lastTime = timestamp;

    if (!gameOver) {
        fallTimer += dt;
        if (fallTimer >= fallInterval) {
            fallTimer = 0;
            if (doesPieceFit(currentPiece, currentRotation, currentX, currentY + 1))
                currentY++;
            else
                lockPiece();
        }
    }

    draw(dt);
    requestAnimationFrame(loop);
}

// ==================== CONTROLES POR TOQUE ====================
canvas.addEventListener("touchstart", (e) => {
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    touchStartTime = performance.now();

    startMusic();
}, { passive: true });

canvas.addEventListener("touchend", (e) => {
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const adx = Math.abs(dx);
    const ady = Math.abs(dy);
    const duration = performance.now() - touchStartTime;

    // game over -> qualquer toque inicia de novo
    if (gameOver) {
        newGame();
        return;
    }

    const now = performance.now();

    // TAP para girar: bem curtinho e quase sem mover
    if (adx < 8 && ady < 8 && duration < 250) {
        if (now - lastRotateTime >= ROTATE_COOLDOWN) {
            const newRot = (currentRotation + 1) % 4;
            if (doesPieceFit(currentPiece, newRot, currentX, currentY)) {
                currentRotation = newRot;
                lastRotateTime = now;
            }
        }
        return;
    }

    // arrastar horizontal = mover
    if (adx > ady) {
        if (dx > 15 && doesPieceFit(currentPiece, currentRotation, currentX + 1, currentY))
            currentX++;
        else if (dx < -15 && doesPieceFit(currentPiece, currentRotation, currentX - 1, currentY))
            currentX--;
    } else {
        // arrastar para baixo = descer um passo
        if (dy > 15 && doesPieceFit(currentPiece, currentRotation, currentX, currentY + 1))
            currentY++;
    }
});

// clique (PC) tamb√©m gira, mais devagar
canvas.addEventListener("click", () => {
    startMusic();
    if (gameOver) {
        newGame();
        return;
    }
    const now = performance.now();
    if (now - lastRotateTime >= ROTATE_COOLDOWN) {
        const newRot = (currentRotation + 1) % 4;
        if (doesPieceFit(currentPiece, newRot, currentX, currentY)) {
            currentRotation = newRot;
            lastRotateTime = now;
        }
    }
});

// ==================== IN√çCIO ====================
newGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
