<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Tetris Mobile - Luisa e Catharina</title>
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

<style>
* {
    box-sizing: border-box;
    font-family: Arial, Helvetica, sans-serif;
}
body {
    margin: 0;
    background-color: #000;
    color: #fff;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;

    /* FOTO DE FUNDO (arquivo background.png no GitHub) */
    background-image: url("background.png");
    background-repeat: no-repeat;
    background-position: center top;
    background-size: contain;
}

#game-container {
    margin-top: 12px;
    padding: 10px;
    background: rgba(0,0,0,0.55);
    border-radius: 16px;
}

#canvas {
    display: block;
    border-radius: 8px;
    background: rgba(0,0,0,0.5);
}

#info {
    margin-top: 4px;
    text-align: center;
    font-size: 13px;
    opacity: 0.9;
}

#info-top {
    margin-top: 4px;
    text-align: center;
    font-size: 13px;
    opacity: 0.95;
}
</style>
</head>
<body>

<div id="info-top">
    Criado por: Luiz Carlos ‚Äî Luisa e Catharina üíñ<br>
    Toque para girar ¬∑ Arraste para mover/baixar
</div>

<div id="game-container">
    <canvas id="canvas" width="240" height="480"></canvas>
    <div id="info">
        Score: <span id="score">0</span> ‚Äî Linhas: <span id="lines">0</span>
    </div>
</div>

<script>
// ===========================
// √ÅUDIO (toca no primeiro toque)
// ===========================
let bgm = new Audio("musica.mp3");
bgm.loop = true;
let musicStarted = false;

function startMusic() {
    if (!musicStarted) {
        musicStarted = true;
        bgm.play().catch(() => {
            // se falhar, deixa para tentar de novo no pr√≥ximo toque
            musicStarted = false;
        });
    }
}

// ===========================
// CONFIGURA√á√ÉO DO TETRIS
// ===========================
const W = 10;          // largura em blocos
const H = 20;          // altura em blocos
const S = 24;          // tamanho de cada bloco em pixels

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

// ajusta o canvas exatamente ao tamanho do campo
canvas.width  = W * S;
canvas.height = H * S;

const scoreSpan = document.getElementById("score");
const linesSpan = document.getElementById("lines");

// campo e pe√ßas
let field = new Array(W * H).fill(0);
let tetromino = [];

// pe√ßas (4x4)
tetromino[0] = "..X." +
               "..X." +
               "..X." +
               "..X."; // I

tetromino[1] = "..X." +
               ".XX." +
               ".X.." +
               "...."; // S

tetromino[2] = ".X.." +
               ".XX." +
               "..X." +
               "...."; // Z

tetromino[3] = "...." +
               ".XX." +
               ".XX." +
               "...."; // O

tetromino[4] = "..X." +
               ".XX." +
               "..X." +
               "...."; // T

tetromino[5] = "...X" +
               ".XXX" +
               "...." +
               "...."; // L

tetromino[6] = "X..." +
               "XXX." +
               "...." +
               "...."; // J

// cores bonitinhas
const colors = [
    "#000000",
    "#00BFFF",
    "#3CB371",
    "#FFA500",
    "#FFD700",
    "#BA55D3",
    "#DC143C",
    "#FF69B4"
];

// estado do jogo
let currentPiece = 0;
let currentRotation = 0;
let currentX = 3;
let currentY = 0;
let nextPiece = 0;

let score = 0;
let lines = 0;
let fallInterval = 500;   // ms
let fallTimer = 0;
let lastTime = 0;
let gameOver = false;

// "Ox√™e!" ao limpar linha
let oxeTimer = 0;
const OXE_DURATION = 800; // ms

// ===========================
// Fun√ß√µes de rota√ß√£o e encaixe
// ===========================
function rotate(px, py, r) {
    switch (r % 4) {
        case 0: return py * 4 + px;
        case 1: return 12 + py - (px * 4);
        case 2: return 15 - (py * 4) - px;
        case 3: return 3 - py + (px * 4);
    }
    return 0;
}

function doesPieceFit(tet, rot, posX, posY) {
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, rot);
            if (tetromino[tet][pi] === "X") {
                const fx = posX + px;
                const fy = posY + py;

                if (fx < 0 || fx >= W || fy < 0 || fy >= H)
                    return false;

                if (field[fy * W + fx] !== 0)
                    return false;
            }
        }
    }
    return true;
}

// ===========================
// Inicializa jogo
// ===========================
function initGame() {
    field.fill(0);
    score = 0;
    lines = 0;
    fallInterval = 500;
    fallTimer = 0;
    oxeTimer = 0;
    gameOver = false;

    currentPiece = Math.floor(Math.random() * 7);
    nextPiece    = Math.floor(Math.random() * 7);
    currentRotation = 0;
    currentX = 3;
    currentY = 0;

    scoreSpan.textContent = score;
    linesSpan.textContent = lines;
}

// trava pe√ßa, checa linhas e gera nova
function lockPiece() {
    // trava no campo
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, currentRotation);
            if (tetromino[currentPiece][pi] === "X") {
                const fx = currentX + px;
                const fy = currentY + py;
                if (fx >= 0 && fx < W && fy >= 0 && fy < H) {
                    field[fy * W + fx] = currentPiece + 1;
                }
            }
        }
    }

    // checa linhas cheias
    let cleared = 0;
    for (let y = 0; y < H; y++) {
        let full = true;
        for (let x = 0; x < W; x++) {
            if (field[y * W + x] === 0) {
                full = false;
                break;
            }
        }
        if (full) {
            cleared++;
            // desce tudo de cima
            for (let yy = y; yy > 0; yy--) {
                for (let x = 0; x < W; x++) {
                    field[yy * W + x] = field[(yy - 1) * W + x];
                }
            }
            // linha de cima fica vazia
            for (let x = 0; x < W; x++) {
                field[x] = 0;
            }
        }
    }

    if (cleared > 0) {
        lines += cleared;
        // pontua√ß√£o
        if (cleared === 1) score += 100;
        else if (cleared === 2) score += 300;
        else if (cleared === 3) score += 500;
        else score += 800;

        scoreSpan.textContent = score;
        linesSpan.textContent = lines;

        oxeTimer = OXE_DURATION;
        if (fallInterval > 120) fallInterval -= 15;
    }

    // nova pe√ßa
    currentPiece = nextPiece;
    nextPiece    = Math.floor(Math.random() * 7);
    currentRotation = 0;
    currentX = 3;
    currentY = 0;

    if (!doesPieceFit(currentPiece, currentRotation, currentX, currentY)) {
        gameOver = true;
    }
}

// ===========================
// Desenho do jogo
// ===========================
function draw(dt) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // fundo
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // grade
    ctx.strokeStyle = "rgba(230,230,230,0.25)";
    ctx.lineWidth = 1;
    for (let x = 0; x <= W; x++) {
        ctx.beginPath();
        ctx.moveTo(x * S, 0);
        ctx.lineTo(x * S, H * S);
        ctx.stroke();
    }
    for (let y = 0; y <= H; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * S);
        ctx.lineTo(W * S, y * S);
        ctx.stroke();
    }

    // blocos travados
    for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
            const v = field[y * W + x];
            if (v > 0) {
                ctx.fillStyle = colors[v % colors.length];
                ctx.fillRect(x * S + 1, y * S + 1, S - 2, S - 2);
            }
        }
    }

    // pe√ßa atual
    if (!gameOver) {
        for (let px = 0; px < 4; px++) {
            for (let py = 0; py < 4; py++) {
                const pi = rotate(px, py, currentRotation);
                if (tetromino[currentPiece][pi] === "X") {
                    const gx = currentX + px;
                    const gy = currentY + py;
                    if (gx >= 0 && gx < W && gy >= 0 && gy < H) {
                        ctx.fillStyle = colors[(currentPiece + 1) % colors.length];
                        ctx.fillRect(gx * S + 1, gy * S + 1, S - 2, S - 2);
                    }
                }
            }
        }
    }

    // "Ox√™e!"
    if (oxeTimer > 0) {
        oxeTimer -= dt;
        ctx.font = "28px Arial";
        ctx.fillStyle = "yellow";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Ox√™e!", canvas.width / 2, canvas.height / 2);
    }

    // Game Over
    if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.65)";
        ctx.fillRect(20, canvas.height / 2 - 40, canvas.width - 40, 80);
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "20px Arial";
        ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 5);
        ctx.font = "14px Arial";
        ctx.fillText("Toque para reiniciar", canvas.width / 2, canvas.height / 2 + 20);
    }
}

// ===========================
// Loop principal
// ===========================
function loop(timestamp) {
    const dt = lastTime ? (timestamp - lastTime) : 0;
    lastTime = timestamp;

    if (!gameOver) {
        fallTimer += dt;
        if (fallTimer >= fallInterval) {
            fallTimer = 0;
            if (doesPieceFit(currentPiece, currentRotation, currentX, currentY + 1)) {
                currentY++;
            } else {
                lockPiece();
            }
        }
    }

    draw(dt);
    requestAnimationFrame(loop);
}

// ===========================
// CONTROLES POR TOQUE / SWIPE
// ===========================
let startX = 0;
let startY = 0;

canvas.addEventListener("touchstart", (e) => {
    const t = e.touches[0];
    startX = t.clientX;
    startY = t.clientY;

    // tenta iniciar m√∫sica
    startMusic();
});

canvas.addEventListener("touchend", (e) => {
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = t.clientY - startY;

    const adx = Math.abs(dx);
    const ady = Math.abs(dy);

    // se estiver em GAME OVER -> reinicia
    if (gameOver) {
        initGame();
        return;
    }

    // toque curto = girar
    if (adx < 10 && ady < 10) {
        const newRot = (currentRotation + 1) % 4;
        if (doesPieceFit(currentPiece, newRot, currentX, currentY)) {
            currentRotation = newRot;
        }
        return;
    }

    // predomin√¢ncia horizontal
    if (adx > ady) {
        if (dx > 15) { // direita
            if (doesPieceFit(currentPiece, currentRotation, currentX + 1, currentY))
                currentX++;
        } else if (dx < -15) { // esquerda
            if (doesPieceFit(currentPiece, currentRotation, currentX - 1, currentY))
                currentX--;
        }
    } else {
        // predomin√¢ncia vertical
        if (dy > 15) { // arrastar para baixo
            if (doesPieceFit(currentPiece, currentRotation, currentX, currentY + 1))
                currentY++;
        }
    }
});

// clique com mouse (PC) tamb√©m gira
canvas.addEventListener("click", () => {
    startMusic();
    if (gameOver) {
        initGame();
        return;
    }
    const newRot = (currentRotation + 1) % 4;
    if (doesPieceFit(currentPiece, newRot, currentX, currentY)) {
        currentRotation = newRot;
    }
});

// ===========================
// In√≠cio do jogo
// ===========================
initGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
