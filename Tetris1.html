<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Tetris Luiz Carlos - Web</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    * {
        box-sizing: border-box;
        font-family: Arial, sans-serif;
    }
    body {
        margin: 0;
        background-color: #000;
        background-image: url("background.png");
        background-repeat: no-repeat;
        background-position: center top;
        background-size: contain; /* mostra a imagem inteira, sem cortar */
        color: #fff;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        min-height: 100vh;
    }
    #game-wrapper {
        margin-top: 10px;
        display: flex;
        gap: 12px;
        align-items: flex-start;
        justify-content: center;
        padding: 8px;
        background: rgba(0,0,0,0.6);
        border-radius: 12px;
    }
    canvas {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid #ccc;
        border-radius: 4px;
        touch-action: none;
    }
    #side-panel {
        min-width: 160px;
        font-size: 14px;
    }
    #side-panel h1 {
        font-size: 16px;
        margin: 0 0 4px 0;
    }
    #side-panel .small {
        font-size: 12px;
        opacity: 0.9;
    }
    #next-box {
        margin-top: 12px;
        padding: 6px;
        background: rgba(0,0,0,0.4);
        border-radius: 6px;
        border: 1px solid #fff;
    }
    #next-label {
        margin-bottom: 4px;
    }
    #next-canvas {
        background: #111;
        border-radius: 4px;
    }
    #controls {
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: center;
    }
    .btn {
        padding: 8px 12px;
        border-radius: 6px;
        border: none;
        background: #2e7dff;
        color: #fff;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
    }
    .btn:active {
        transform: scale(0.95);
        background: #1b57b8;
    }
    #menu-overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
    }
    #menu-card {
        background: rgba(0,0,0,0.9);
        border-radius: 16px;
        padding: 20px 24px;
        text-align: center;
        max-width: 320px;
        border: 1px solid #fff;
    }
    #menu-card h1 {
        margin: 0 0 10px 0;
        font-size: 20px;
    }
    #menu-card p {
        margin: 4px 0;
        font-size: 14px;
    }
    #menu-buttons {
        margin-top: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    @media (max-width: 700px) {
        #game-wrapper {
            flex-direction: column;
            align-items: center;
        }
    }
</style>
</head>
<body>

<div id="menu-overlay">
    <div id="menu-card">
        <h1>TETRIS GRÁFICO - WEB</h1>
        <p>Criado por: Luiz Carlos</p>
        <p>Luisa e Catharina</p>
        <p style="margin-top:8px;" class="small">
            Controles teclado: ← → ↓ e Z<br>
            Controles toque: botões abaixo do jogo
        </p>
        <div id="menu-buttons">
            <button class="btn" id="btn-play">JOGAR</button>
            <button class="btn" id="btn-exit">SAIR</button>
        </div>
    </div>
</div>

<div id="game-wrapper">
    <canvas id="game-canvas" width="320" height="520"></canvas>

    <div id="side-panel">
        <h1>Tetris em C++ / Web</h1>
        <div class="small">Criado por: Luiz Carlos</div>
        <div class="small">Email: lcberk@gmail.com</div>
        <div style="margin-top:8px;font-weight:bold;">Luisa e Catharina</div>

        <div style="margin-top:10px;">
            <div>Setas: mover / descer</div>
            <div>Z: girar peça</div>
        </div>

        <div style="margin-top:10px;">
            <div id="score-label">Score: 0</div>
            <div id="lines-label">Linhas: 0</div>
        </div>

        <div id="next-box">
            <div id="next-label">Próxima peça:</div>
            <canvas id="next-canvas" width="80" height="80"></canvas>
        </div>

        <div id="controls">
            <button class="btn" id="btn-left">←</button>
            <button class="btn" id="btn-rotate">Z</button>
            <button class="btn" id="btn-right">→</button>
            <button class="btn" id="btn-down">↓</button>
        </div>
    </div>
</div>

<script>
// ---------------------------
// Configuração
// ---------------------------
const FIELD_WIDTH  = 10;
const FIELD_HEIGHT = 20;
const CELL_SIZE    = 24;

const canvas = document.getElementById('game-canvas');
const ctx    = canvas.getContext('2d');

const nextCanvas = document.getElementById('next-canvas');
const nextCtx    = nextCanvas.getContext('2d');

const scoreLabel = document.getElementById('score-label');
const linesLabel = document.getElementById('lines-label');

canvas.width  = FIELD_WIDTH * CELL_SIZE;
canvas.height = FIELD_HEIGHT * CELL_SIZE;

// campo e peças
let field = new Array(FIELD_WIDTH * FIELD_HEIGHT).fill(0);
let tetromino = [];

tetromino[0] = "..X." +
               "..X." +
               "..X." +
               "..X."; // I

tetromino[1] = "..X." +
               ".XX." +
               ".X.." +
               "...."; // S

tetromino[2] = ".X.." +
               ".XX." +
               "..X." +
               "...."; // Z

tetromino[3] = "...." +
               ".XX." +
               ".XX." +
               "...."; // O

tetromino[4] = "..X." +
               ".XX." +
               "..X." +
               "...."; // T

tetromino[5] = "...." +
               ".XX." +
               "..X." +
               "..X."; // L

tetromino[6] = "...." +
               ".XX." +
               ".X.." +
               ".X.."; // J

const STATE_MENU    = 0;
const STATE_PLAYING = 1;
const STATE_GAMEOVER= 2;

let gameState = STATE_MENU;

let currentPiece    = 0;
let currentRotation = 0;
let currentX        = 0;
let currentY        = 0;
let nextPiece       = 0;

let score      = 0;
let totalLines = 0;
let fallInterval = 500;
let fallTimer    = 0;

let lastTime = 0;

// "Oxêe!"
let oxeTimer = 0;
const OXE_DURATION = 800;

// música (Google Drive)
let bgm = new Audio("musica.mp3");
bgm.loop = true;


// cores
const colors = [
  "#000000",
  "#00BFFF",
  "#3CB371",
  "#FFA500",
  "#FFD700",
  "#BA55D3",
  "#DC143C",
  "#FF69B4"
];

// ---------------------------
// Funções auxiliares
// ---------------------------
function rotate(px, py, r) {
    switch (r % 4) {
        case 0: return py * 4 + px;
        case 1: return 12 + py - (px * 4);
        case 2: return 15 - (py * 4) - px;
        case 3: return 3 - py + (px * 4);
    }
    return 0;
}

function doesPieceFit(tet, rot, posX, posY) {
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, rot);
            if (tetromino[tet][pi] === 'X') {
                const fx = posX + px;
                const fy = posY + py;

                if (fx < 0 || fx >= FIELD_WIDTH ||
                    fy < 0 || fy >= FIELD_HEIGHT) {
                    return false;
                }

                const fi = fy * FIELD_WIDTH + fx;
                if (field[fi] !== 0) return false;
            }
        }
    }
    return true;
}

function initGame() {
    field.fill(0);
    score      = 0;
    totalLines = 0;
    fallInterval = 500;
    fallTimer    = 0;
    oxeTimer     = 0;

    currentPiece    = Math.floor(Math.random()*7);
    nextPiece       = Math.floor(Math.random()*7);
    currentRotation = 0;
    currentX        = Math.floor(FIELD_WIDTH/2) - 2;
    currentY        = 0;

    scoreLabel.textContent = "Score: 0";
    linesLabel.textContent = "Linhas: 0";
}

function lockPiece() {
    for (let px = 0; px < 4; px++) {
        for (let py = 0; py < 4; py++) {
            const pi = rotate(px, py, currentRotation);
            if (tetromino[currentPiece][pi] === 'X') {
                const fx = currentX + px;
                const fy = currentY + py;
                if (fx >= 0 && fx < FIELD_WIDTH &&
                    fy >= 0 && fy < FIELD_HEIGHT) {
                    field[fy * FIELD_WIDTH + fx] = currentPiece + 1;
                }
            }
        }
    }

    let linesThisDrop = 0;
    for (let y = 0; y < FIELD_HEIGHT; y++) {
        let full = true;
        for (let x = 0; x < FIELD_WIDTH; x++) {
            if (field[y * FIELD_WIDTH + x] === 0) {
                full = false;
                break;
            }
        }
        if (full) {
            linesThisDrop++;
            for (let yy = y; yy > 0; yy--) {
                for (let x = 0; x < FIELD_WIDTH; x++) {
                    field[yy * FIELD_WIDTH + x] =
                        field[(yy-1)*FIELD_WIDTH + x];
                }
            }
            for (let x = 0; x < FIELD_WIDTH; x++) {
                field[x] = 0;
            }
        }
    }

    if (linesThisDrop > 0) {
        totalLines += linesThisDrop;
        switch (linesThisDrop) {
            case 1: score += 100; break;
            case 2: score += 300; break;
            case 3: score += 500; break;
            case 4: score += 800; break;
            default: score += linesThisDrop * 100; break;
        }
        scoreLabel.textContent = "Score: " + score;
        linesLabel.textContent = "Linhas: " + totalLines;

        oxeTimer = OXE_DURATION;
        if (fallInterval > 120) fallInterval -= 15;
    }

    currentPiece    = nextPiece;
    nextPiece       = Math.floor(Math.random()*7);
    currentRotation = 0;
    currentX        = Math.floor(FIELD_WIDTH/2) - 2;
    currentY        = 0;

    if (!doesPieceFit(currentPiece, currentRotation, currentX, currentY)) {
        gameState = STATE_GAMEOVER;
    }
}

// ---------------------------
// Desenho
// ---------------------------
function drawNextPiece() {
    nextCtx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nextCtx.fillStyle = "#111";
    nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);

    const cell = 16;
    for (let px=0; px<4; px++) {
        for (let py=0; py<4; py++) {
            const pi = rotate(px, py, 0);
            if (tetromino[nextPiece][pi] === 'X') {
                nextCtx.fillStyle = colors[(nextPiece+1)%8];
                nextCtx.fillRect(
                    px*cell + 4,
                    py*cell + 4,
                    cell-2, cell-2
                );
            }
        }
    }
}

function drawGame(dt) {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = "rgba(0,0,0,0.4)";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = "rgba(230,230,230,0.4)";
    ctx.lineWidth = 1;
    for (let x=0;x<=FIELD_WIDTH;x++){
        ctx.beginPath();
        ctx.moveTo(x*CELL_SIZE, 0);
        ctx.lineTo(x*CELL_SIZE, FIELD_HEIGHT*CELL_SIZE);
        ctx.stroke();
    }
    for (let y=0;y<=FIELD_HEIGHT;y++){
        ctx.beginPath();
        ctx.moveTo(0, y*CELL_SIZE);
        ctx.lineTo(FIELD_WIDTH*CELL_SIZE, y*CELL_SIZE);
        ctx.stroke();
    }

    for (let y=0;y<FIELD_HEIGHT;y++){
        for (let x=0;x<FIELD_WIDTH;x++){
            const v = field[y*FIELD_WIDTH + x];
            if (v>0) {
                ctx.fillStyle = colors[v%8];
                ctx.fillRect(
                    x*CELL_SIZE+1,
                    y*CELL_SIZE+1,
                    CELL_SIZE-2,
                    CELL_SIZE-2
                );
            }
        }
    }

    if (gameState === STATE_PLAYING) {
        for (let px=0;px<4;px++){
            for (let py=0;py<4;py++){
                const pi = rotate(px,py,currentRotation);
                if (tetromino[currentPiece][pi] === 'X') {
                    const gx = currentX + px;
                    const gy = currentY + py;
                    if (gx>=0 && gx<FIELD_WIDTH &&
                        gy>=0 && gy<FIELD_HEIGHT){
                        ctx.fillStyle = colors[(currentPiece+1)%8];
                        ctx.fillRect(
                            gx*CELL_SIZE+1,
                            gy*CELL_SIZE+1,
                            CELL_SIZE-2,
                            CELL_SIZE-2
                        );
                    }
                }
            }
        }
    }

    if (oxeTimer > 0) {
        oxeTimer -= dt;
        ctx.font = "30px Arial";
        ctx.fillStyle = "yellow";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
            "Oxêe!",
            (FIELD_WIDTH*CELL_SIZE)/2,
            (FIELD_HEIGHT*CELL_SIZE)/2
        );
    }

    if (gameState === STATE_GAMEOVER) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(20, 150, canvas.width-40, 80);
        ctx.font = "18px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("GAME OVER", canvas.width/2, 175);
        ctx.font = "14px Arial";
        ctx.fillText("Toque em JOGAR para reiniciar", canvas.width/2, 205);
    }
}

// ---------------------------
// Loop
// ---------------------------
function gameLoop(timestamp) {
    const dt = lastTime ? (timestamp - lastTime) : 0;
    lastTime = timestamp;

    if (gameState === STATE_PLAYING) {
        fallTimer += dt;
        if (fallTimer >= fallInterval) {
            fallTimer = 0;
            if (doesPieceFit(currentPiece, currentRotation, currentX, currentY+1)) {
                currentY++;
            } else {
                lockPiece();
            }
        }
    }

    drawGame(dt);
    drawNextPiece();
    requestAnimationFrame(gameLoop);
}

// ---------------------------
// Controles
// ---------------------------
function tryMove(dx, dy) {
    if (gameState !== STATE_PLAYING) return;
    if (doesPieceFit(currentPiece, currentRotation, currentX + dx, currentY + dy)) {
        currentX += dx;
        currentY += dy;
    }
}

function tryRotate() {
    if (gameState !== STATE_PLAYING) return;
    const newRot = (currentRotation + 1) % 4;
    if (doesPieceFit(currentPiece, newRot, currentX, currentY)) {
        currentRotation = newRot;
    }
}

window.addEventListener('keydown', (e) => {
    if (gameState === STATE_MENU) {
        if (e.key === "Enter") {
            startGame();
        }
        return;
    }

    if (gameState === STATE_PLAYING) {
        if (e.key === "ArrowLeft")      tryMove(-1,0);
        else if (e.key === "ArrowRight")tryMove(1,0);
        else if (e.key === "ArrowDown") tryMove(0,1);
        else if (e.key === "z" || e.key === "Z") tryRotate();
    } else if (gameState === STATE_GAMEOVER) {
        if (e.key === "Enter") startGame();
    }
});

document.getElementById('btn-left').addEventListener('click', () => tryMove(-1,0));
document.getElementById('btn-right').addEventListener('click', () => tryMove(1,0));
document.getElementById('btn-down').addEventListener('click', () => tryMove(0,1));
document.getElementById('btn-rotate').addEventListener('click', () => tryRotate());

document.getElementById('btn-play').addEventListener('click', () => startGame());
document.getElementById('btn-exit').addEventListener('click', () => {
    alert("Para sair, feche a aba do navegador.");
});

// ---------------------------
// Início / Música
// ---------------------------
function startGame() {
    initGame();
    gameState = STATE_PLAYING;
    document.getElementById('menu-overlay').style.display = "none";

    bgm.play().catch(err => {
        console.warn("Não foi possível iniciar a música automaticamente:", err);
    });
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
